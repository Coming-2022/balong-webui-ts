import type { Server } from 'socket.io';
import { ATClient } from '../services/ATClient';
import { DeviceMonitor } from '../services/DeviceMonitor';
import { logger, logATCommand } from '../utils/logger';
import { AT_COMMANDS } from '../config';

import type { 
  ServerToClientEvents, 
  ClientToServerEvents,
  APIResponse
} from '../../types';

// å°åŒºæ‰«æçŠ¶æ€ç®¡ç†
let cellScanInProgress = false;
let cellScanResults: any[] = [];

// è§£æå°åŒºæ‰«æå“åº”
const parseCellScanResponse = (response: string) => {
  const results: any[] = [];
  const lines = response.split('\n');
  
  for (const line of lines) {
    if (line.startsWith('^CELLSCAN: ')) {
      try {
        const data = line.split(': ', 2)[1];
        const fields = data.split(',');
        
        if (fields.length >= 15) { // ç¡®ä¿æœ‰è¶³å¤Ÿçš„å­—æ®µ
          const rat = parseInt(fields[0]);
          let ratStr = 'Unknown';
          
          switch (rat) {
            case 1: ratStr = 'UMTS (FDD)'; break;
            case 2: ratStr = 'LTE'; break;
            case 3: ratStr = 'NR'; break;
          }
          
          // æ ¹æ®Pythonä»£ç çš„æ­£ç¡®å­—æ®µç´¢å¼•
          const record = {
            rat: ratStr,
            plmn: fields[1]?.replace(/"/g, '') || '',
            freq: parseInt(fields[2]) || 0,
            pci: parseInt(fields[3]) || 0,
            band: parseInt(fields[4], 16) || 0,
            lac: parseInt(fields[5], 16) || 0,
            scs: getSCSValue(parseInt(fields[10]) || 0),
            rsrp: parseInt(fields[11]) || 0,  // æ­£ç¡®çš„RSRPå­—æ®µ
            rsrq: fields[12] ? parseInt(fields[12]) * 0.5 : 0,  // æ­£ç¡®çš„RSRQå­—æ®µï¼Œéœ€è¦ä¹˜ä»¥0.5
            sinr: fields[13] ? parseInt(fields[13]) * 0.5 : 0,  // æ­£ç¡®çš„SINRå­—æ®µï¼Œéœ€è¦ä¹˜ä»¥0.5
            lte_sinr: fields[14] ? parseInt(fields[14], 16) * 0.125 : 0,  // LTE SINRå­—æ®µï¼Œéœ€è¦ä¹˜ä»¥0.125
            timestamp: new Date().toISOString()
          };
          
          results.push(record);
        }
      } catch (error) {
        logger.warn(`è§£æå°åŒºæ‰«æè¡Œå¤±è´¥: ${line}`, error);
      }
    }
  }
  
  return results;
};

// SCSå€¼æ˜ å°„å‡½æ•°
const getSCSValue = (scs: number): string => {
  const scsMap: { [key: number]: string } = {
    0: '15',
    1: '30',
    2: '60',
    3: '120',
    4: '240'
  };
  return scsMap[scs] || '15';
};

export function setupSocketHandlers(
  io: Server<ClientToServerEvents, ServerToClientEvents>,
  atClient: ATClient,
  deviceMonitor: DeviceMonitor
): void {
  
  io.on('connection', (socket) => {
    const clientId = socket.id;
    const clientIP = socket.handshake.address;
    
    logger.info('å®¢æˆ·ç«¯è¿æ¥', { clientId, clientIP });

    // å‘é€å½“å‰è®¾å¤‡çŠ¶æ€
    const currentData = deviceMonitor.getCurrentData();
    socket.emit('deviceUpdate', {
      connected: atClient.connected,
      signal: currentData.signal || undefined,
      temperature: currentData.temperature || undefined,
      nrccStatus: currentData.nrccStatus || undefined,
      lockStatus: currentData.lockStatus || undefined,
      monitoring: currentData.monitoring
    });

    // å¤„ç†ATå‘½ä»¤å‘é€
    socket.on('sendCommand', async (command: string, callback) => {
      try {
        if (!command || typeof command !== 'string') {
          callback({
            success: false,
            error: 'å‘½ä»¤ä¸èƒ½ä¸ºç©º',
            timestamp: new Date().toISOString()
          });
          return;
        }

        const startTime = Date.now();
        const response = await atClient.sendCommand(command.trim());
        const duration = Date.now() - startTime;
        
        logATCommand(command, response);
        
        callback({
          success: true,
          data: {
            command,
            response,
            duration
          },
          timestamp: new Date().toISOString()
        });

      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'å‘½ä»¤æ‰§è¡Œå¤±è´¥';
        logATCommand(command, undefined, errorMessage);
        
        callback({
          success: false,
          error: errorMessage,
          timestamp: new Date().toISOString()
        });
      }
    });

    // è·å–ä¿¡å·æ•°æ®
    socket.on('getSignal', async (callback) => {
      try {
        const response = await atClient.sendCommand(AT_COMMANDS.view_signal);
        const signalData = atClient.parseSignalInfo(response);
        
        if (!signalData) {
          callback({
            success: false,
            error: 'ä¿¡å·æ•°æ®è§£æå¤±è´¥',
            timestamp: new Date().toISOString()
          });
          return;
        }

        callback({
          success: true,
          data: signalData,
          timestamp: new Date().toISOString()
        });

      } catch (error) {
        callback({
          success: false,
          error: error instanceof Error ? error.message : 'è·å–ä¿¡å·å¤±è´¥',
          timestamp: new Date().toISOString()
        });
      }
    });

    // è·å–5GçŠ¶æ€
    socket.on('get5GStatus', async (callback) => {
      try {
        const response = await atClient.sendCommand(AT_COMMANDS.view_5g_nr_cc_status);
        const nrccData = atClient.parse5GStatus(response);
        
        if (!nrccData) {
          callback({
            success: false,
            error: '5GçŠ¶æ€æ•°æ®è§£æå¤±è´¥',
            timestamp: new Date().toISOString()
          });
          return;
        }

        callback({
          success: true,
          data: nrccData,
          timestamp: new Date().toISOString()
        });

      } catch (error) {
        callback({
          success: false,
          error: error instanceof Error ? error.message : 'è·å–5GçŠ¶æ€å¤±è´¥',
          timestamp: new Date().toISOString()
        });
      }
    });

    // é”å®šå°åŒº
    socket.on('lockCell', async (cellId: string, callback) => {
      try {
        if (!cellId || !(cellId in AT_COMMANDS)) {
          callback({
            success: false,
            error: 'æ— æ•ˆçš„å°åŒºID',
            timestamp: new Date().toISOString()
          });
          return;
        }

        // å‘é€é”å®šå‘½ä»¤
        const lockResponse = await atClient.sendCommand(AT_COMMANDS[cellId as keyof typeof AT_COMMANDS] as string);
        
        if (!lockResponse.includes('OK')) {
          callback({
            success: false,
            error: 'å°åŒºé”å®šå¤±è´¥',
            data: lockResponse,
            timestamp: new Date().toISOString()
          });
          return;
        }

        // é‡å¯è®¾å¤‡
        const restartResponse = await atClient.sendCommand(AT_COMMANDS.restart_cellular);
        
        callback({
          success: true,
          message: 'å°åŒºé”å®šæˆåŠŸï¼Œè®¾å¤‡æ­£åœ¨é‡å¯',
          data: {
            lockResponse,
            restartResponse
          },
          timestamp: new Date().toISOString()
        });

        // é€šçŸ¥æ‰€æœ‰å®¢æˆ·ç«¯
        io.emit('deviceUpdate', { restarting: true });

      } catch (error) {
        callback({
          success: false,
          error: error instanceof Error ? error.message : 'å°åŒºé”å®šå¤±è´¥',
          timestamp: new Date().toISOString()
        });
      }
    });

    // è§£é”å°åŒº
    socket.on('unlockCell', async (callback) => {
      try {
        const response = await atClient.sendCommand(AT_COMMANDS.unlock_cell);
        
        callback({
          success: true,
          message: 'å°åŒºè§£é”æˆåŠŸ',
          data: response,
          timestamp: new Date().toISOString()
        });

        // è§¦å‘é”å®šçŠ¶æ€æ›´æ–°
        setTimeout(() => {
          deviceMonitor.triggerMonitoring(['lock_status']);
        }, 1000);

      } catch (error) {
        callback({
          success: false,
          error: error instanceof Error ? error.message : 'å°åŒºè§£é”å¤±è´¥',
          timestamp: new Date().toISOString()
        });
      }
    });

    // æµ‹è¯•äº‹ä»¶å¤„ç†å™¨
    socket.on('test', (data, callback) => {
      logger.info('æ”¶åˆ°æµ‹è¯•äº‹ä»¶:', data);
      if (callback) {
        callback({
          success: true,
          message: 'æµ‹è¯•äº‹ä»¶å¤„ç†æˆåŠŸ',
          data: data,
          timestamp: new Date().toISOString()
        });
      }
    });

    // åˆå§‹åŒ–é…ç½®
    socket.on('initConfiguration', async (callback) => {
      try {
        logger.info('æ”¶åˆ°åˆå§‹åŒ–é…ç½®è¯·æ±‚');
        
        if (cellScanInProgress) {
          logger.warn('å°åŒºæ‰«ææ­£åœ¨è¿›è¡Œä¸­ï¼Œæ‹’ç»åˆå§‹åŒ–é…ç½®è¯·æ±‚');
          callback({
            success: false,
            error: 'å°åŒºæ‰«ææ­£åœ¨è¿›è¡Œä¸­ï¼Œè¯·ç¨åå†è¯•',
            timestamp: new Date().toISOString()
          });
          return;
        }

        const commands = [
          { cmd: 'AT^C5GOPTION=1,1,1', desc: 'è®¾ç½®5Gé€‰é¡¹' },
          { cmd: 'AT^LTEFREQLOCK=0', desc: 'è§£é”LTEé¢‘ç‡' },
          { cmd: 'AT^NRFREQLOCK=0', desc: 'è§£é”NRé¢‘ç‡' },
          { cmd: 'AT^SYSCFGEX="0803",3FFFFFFF,1,2,7FFFFFFFFFFFFFFF,,', desc: 'é…ç½®ç³»ç»Ÿå‚æ•°' }
        ];

        logger.info('å‘é€åˆå§‹è¿›åº¦äº‹ä»¶');
        socket.emit('scanProgress', { 
          stage: 'init', 
          message: 'å¼€å§‹åˆå§‹åŒ–é…ç½®...', 
          progress: 0 
        });

        logger.info('å¼€å§‹æ‰§è¡Œåˆå§‹åŒ–é…ç½®');

        for (let i = 0; i < commands.length; i++) {
          const { cmd, desc } = commands[i];
          const progress = Math.round(((i + 1) / commands.length) * 100);
          
          logger.info(`æ‰§è¡Œåˆå§‹åŒ–å‘½ä»¤ ${i + 1}/${commands.length}: ${cmd}`);
          
          logger.info(`å‘é€è¿›åº¦äº‹ä»¶: ${desc}`);
          socket.emit('scanProgress', { 
            stage: 'init', 
            message: `${desc}: ${cmd}`, 
            progress: Math.round((i / commands.length) * 100) 
          });

          // å‚è€ƒPythonç‰ˆæœ¬çš„é‡è¯•é€»è¾‘
          let response = '';
          let retryCount = 0;
          const maxRetries = 3;
          
          while (retryCount < maxRetries) {
            try {
              logger.info(`å‘é€ATå‘½ä»¤: ${cmd} (å°è¯• ${retryCount + 1}/${maxRetries})`);
              response = await atClient.sendCommand(cmd);
              logger.info(`ATå‘½ä»¤å“åº”: ${response.substring(0, 100)}...`);
              
              if (response.includes('OK')) {
                logger.info(`å‘½ä»¤æ‰§è¡ŒæˆåŠŸ ${i + 1}/${commands.length}: ${cmd}`);
                break; // æˆåŠŸï¼Œè·³å‡ºé‡è¯•å¾ªç¯
              } else {
                logger.warn(`å‘½ä»¤ '${cmd}' æœªè¿”å›OKï¼Œå“åº”: ${response}`);
                retryCount++;
                
                if (retryCount < maxRetries) {
                  logger.info(`å‘½ä»¤ '${cmd}' å¤±è´¥ï¼Œé‡è¯•ä¸­... (${retryCount}/${maxRetries})`);
                  socket.emit('scanProgress', { 
                    stage: 'init', 
                    message: `${desc} - é‡è¯•ä¸­ (${retryCount}/${maxRetries})`, 
                    progress: Math.round((i / commands.length) * 100) 
                  });
                  await new Promise(resolve => setTimeout(resolve, 2000)); // ç­‰å¾…2ç§’åé‡è¯•
                } else {
                  throw new Error(`å‘½ä»¤æ‰§è¡Œå¤±è´¥ï¼Œå·²é‡è¯•${maxRetries}æ¬¡: ${cmd} - å“åº”: ${response}`);
                }
              }
            } catch (cmdError) {
              retryCount++;
              logger.error(`å‘½ä»¤æ‰§è¡Œå¼‚å¸¸ ${retryCount}/${maxRetries}: ${cmd}`, cmdError);
              
              if (retryCount < maxRetries) {
                socket.emit('scanProgress', { 
                  stage: 'init', 
                  message: `${desc} - é‡è¯•ä¸­ (${retryCount}/${maxRetries})`, 
                  progress: Math.round((i / commands.length) * 100) 
                });
                await new Promise(resolve => setTimeout(resolve, 2000));
              } else {
                throw new Error(`å‘½ä»¤æ‰§è¡Œå¤±è´¥: ${cmd} - ${cmdError instanceof Error ? cmdError.message : 'æœªçŸ¥é”™è¯¯'}`);
              }
            }
          }
          
          // æ›´æ–°è¿›åº¦
          logger.info(`å‘é€å®Œæˆè¿›åº¦äº‹ä»¶: ${desc}`);
          socket.emit('scanProgress', { 
            stage: 'init', 
            message: `${desc} - å®Œæˆ`, 
            progress: progress
          });
          
          // å‘½ä»¤é—´å»¶è¿Ÿï¼Œå‚è€ƒPythonç‰ˆæœ¬
          if (i < commands.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
        }

        logger.info('å‘é€æœ€ç»ˆå®Œæˆäº‹ä»¶');
        socket.emit('scanProgress', { 
          stage: 'init', 
          message: 'åˆå§‹åŒ–é…ç½®å®Œæˆï¼', 
          progress: 100 
        });

        logger.info('åˆå§‹åŒ–é…ç½®å®Œæˆ');

        callback({
          success: true,
          message: 'åˆå§‹åŒ–é…ç½®å®Œæˆ',
          data: {
            commandsExecuted: commands.length,
            commands: commands.map(c => c.cmd)
          },
          timestamp: new Date().toISOString()
        });

      } catch (error) {
        logger.error('åˆå§‹åŒ–é…ç½®å¤±è´¥:', error);
        
        socket.emit('scanError', { 
          stage: 'init', 
          message: 'åˆå§‹åŒ–é…ç½®å¤±è´¥', 
          error: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯' 
        });
        
        callback({
          success: false,
          error: error instanceof Error ? error.message : 'åˆå§‹åŒ–é…ç½®å¤±è´¥',
          timestamp: new Date().toISOString()
        });
      }
    });

    // å¼€å§‹å°åŒºæ‰«æ - åŸºäºPythonç‰ˆæœ¬é€»è¾‘
    socket.on('startScan', async (callback) => {
      try {
        if (cellScanInProgress) {
          callback({
            success: false,
            error: 'å°åŒºæ‰«ææ­£åœ¨è¿›è¡Œä¸­ï¼Œè¯·ç¨åå†è¯•',
            timestamp: new Date().toISOString()
          });
          return;
        }

        cellScanInProgress = true;
        cellScanResults = [];

        socket.emit('scanProgress', { 
          stage: 'scan', 
          message: 'å¼€å§‹å°åŒºæ‰«æ...', 
          progress: 0 
        });

        logger.info('å¼€å§‹å°åŒºæ‰«æ');

        // 1. è§£é”å°åŒº - å‚è€ƒPythonç‰ˆæœ¬ï¼Œåªä½¿ç”¨AT^NRFREQLOCK=0
        socket.emit('scanProgress', { 
          stage: 'scan', 
          message: 'è§£é”å°åŒº...', 
          progress: 10 
        });
        
        logger.info('æ‰§è¡Œè§£é”å°åŒºå‘½ä»¤: AT^NRFREQLOCK=0');
        await atClient.sendCommand('AT^NRFREQLOCK=0');
        logger.info('å°åŒºè§£é”å®Œæˆ');

        // 2. æ‰§è¡Œ AT+COPS=2 (å‚è€ƒPythonç‰ˆæœ¬çš„é‡è¯•é€»è¾‘)
        socket.emit('scanProgress', { 
          stage: 'scan', 
          message: 'æ–­å¼€ç½‘ç»œè¿æ¥...', 
          progress: 20 
        });
        
        logger.info('æ‰§è¡ŒAT+COPS=2å‘½ä»¤');
        let response = await atClient.sendCommand('AT+COPS=2');
        let retries = 0;
        while (!response.includes('OK') && retries < 5) {
          logger.warn(`AT+COPS=2å¤±è´¥ï¼Œé‡è¯• ${retries + 1}/5`);
          socket.emit('scanProgress', { 
            stage: 'scan', 
            message: `æ–­å¼€ç½‘ç»œè¿æ¥ - é‡è¯• ${retries + 1}/5`, 
            progress: 20 
          });
          await new Promise(resolve => setTimeout(resolve, 2000));
          response = await atClient.sendCommand('AT+COPS=2');
          retries++;
        }
        
        if (!response.includes('OK')) {
          throw new Error('æ— æ³•æ–­å¼€ç½‘ç»œè¿æ¥ï¼ŒAT+COPS=2æ‰§è¡Œå¤±è´¥');
        }
        logger.info('AT+COPS=2æ‰§è¡ŒæˆåŠŸ');

        // 3. æ‰§è¡Œå°åŒºæ‰«æ - å®Œå…¨æŒ‰ç…§Pythonç‰ˆæœ¬çš„é€»è¾‘
        socket.emit('scanProgress', { 
          stage: 'scan', 
          message: 'æ­£åœ¨æ‰«æå°åŒºï¼Œè¿™å¯èƒ½éœ€è¦1-2åˆ†é’Ÿ...', 
          progress: 30 
        });

        logger.info('å¼€å§‹æ‰§è¡ŒAT^CELLSCAN=3å¾ªç¯ - æŒ‰ç…§Pythonç‰ˆæœ¬é€»è¾‘');
        const startTime = Date.now();
        
        let scanResponse = '';
        let cellscanCompleted = false;
        let attempts = 0;
        const maxAttempts = 60;
        
        while (!cellscanCompleted && attempts < maxAttempts) {
          attempts++;
          logger.info(`ç­‰å¾…AT^CELLSCAN=3å®Œæˆ... (å°è¯• ${attempts}/${maxAttempts})`);
          
          socket.emit('scanProgress', { 
            stage: 'scan', 
            message: `æ‰«æå°åŒºä¸­... (${attempts}/${maxAttempts})`, 
            progress: Math.min(30 + (attempts / maxAttempts) * 50, 80)
          });
          
          // ç­‰å¾…2ç§’ï¼Œå‚è€ƒPythonç‰ˆæœ¬
          await new Promise(resolve => setTimeout(resolve, 2000));
          
          try {
            const newResponse = await atClient.sendCommand('AT^CELLSCAN=3');
            logger.info(`CELLSCANå“åº” ${attempts}: ${newResponse ? newResponse.substring(0, 100) + '...' : 'null'}`);
            
            if (newResponse && newResponse.trim()) {
              scanResponse += newResponse;
              
              // æ£€æŸ¥æ˜¯å¦åŒ…å«å°åŒºæ•°æ®
              if (newResponse.includes('^CELLSCAN:')) {
                const cellCount = (newResponse.match(/\^CELLSCAN:/g) || []).length;
                logger.info(`å‘ç° ${cellCount} ä¸ªå°åŒºä¿¡æ¯`);
                socket.emit('scanProgress', { 
                  stage: 'scan', 
                  message: `å‘ç° ${cellCount} ä¸ªå°åŒºä¿¡æ¯...`, 
                  progress: Math.min(30 + (attempts / maxAttempts) * 50, 80)
                });
              }
              
              // æ£€æŸ¥æ˜¯å¦å®Œæˆ
              if (newResponse.includes('OK')) {
                logger.info('å°åŒºæ‰«æå®Œæˆï¼Œæ”¶åˆ°OKå“åº”');
                cellscanCompleted = true;
              }
            } else {
              logger.warn('æœªæ”¶åˆ°å“åº”ï¼Œç»§ç»­é‡è¯•');
            }
          } catch (error) {
            logger.warn(`CELLSCANå°è¯• ${attempts} å¤±è´¥:`, error);
          }
        }
        
        const duration = Date.now() - startTime;
        
        if (!cellscanCompleted) {
          throw new Error(`å°åŒºæ‰«æè¶…æ—¶ (å°è¯•äº†${attempts}æ¬¡ï¼Œè€—æ—¶${duration}ms)`);
        }
        
        logger.info(`å°åŒºæ‰«æå®Œæˆï¼Œè€—æ—¶: ${duration}ms, æ€»å“åº”é•¿åº¦: ${scanResponse.length}`);

        // ğŸ”§ ä¿®å¤: ç«‹å³å¤„ç†ç»“æœï¼Œä¸ç­‰å¾…ç½‘ç»œæ¢å¤
        socket.emit('scanProgress', { 
          stage: 'scan', 
          message: 'è§£ææ‰«æç»“æœ...', 
          progress: 85 
        });

        // è§£ææ‰«æç»“æœ
        const results = atClient.parseCellScanResults(scanResponse);
        logger.info(`å°åŒºæ‰«æå®Œæˆï¼Œå‘ç° ${results.length} ä¸ªå°åŒº`);

        // ğŸ”§ å…³é”®ä¿®å¤: ç«‹å³è¿”å›ç»“æœç»™å‰ç«¯ï¼Œä¸ç­‰å¾…AT+COPS=0
        socket.emit('scanComplete', {
          success: true,
          results: results,
          count: results.length,
          duration: duration,
          timestamp: new Date().toISOString()
        });

        // ğŸ”§ å¼‚æ­¥æ¢å¤ç½‘ç»œï¼Œä¸é˜»å¡ç»“æœè¿”å›
        setImmediate(async () => {
          try {
            logger.info('å¼‚æ­¥æ‰§è¡ŒAT+COPS=0æ¢å¤ç½‘ç»œ');
            socket.emit('scanProgress', { 
              stage: 'scan', 
              message: 'æ¢å¤ç½‘ç»œè¿æ¥...', 
              progress: 95 
            });
            
            // ä½¿ç”¨æ›´é•¿çš„è¶…æ—¶æ—¶é—´ï¼Œé¿å…é˜»å¡
            const restoreResponse = await atClient.sendCommand('AT+COPS=0', 15000);
            if (restoreResponse.includes('OK')) {
              logger.info('ç½‘ç»œè¿æ¥å·²æ¢å¤');
              socket.emit('scanProgress', { 
                stage: 'scan', 
                message: 'ç½‘ç»œè¿æ¥å·²æ¢å¤', 
                progress: 100 
              });
            } else {
              logger.warn('ç½‘ç»œæ¢å¤å¯èƒ½å¤±è´¥ï¼Œä½†ä¸å½±å“æ‰«æç»“æœ');
            }
          } catch (restoreError) {
            logger.warn('ç½‘ç»œæ¢å¤å¤±è´¥ï¼Œä½†æ‰«æç»“æœå·²æˆåŠŸè¿”å›:', restoreError);
            // ä¸æŠ›å‡ºé”™è¯¯ï¼Œå› ä¸ºæ‰«æç»“æœå·²ç»æˆåŠŸè¿”å›
          } finally {
            cellScanInProgress = false;
          }
        });

        // ç«‹å³å“åº”æˆåŠŸ
        callback({
          success: true,
          message: `æ‰«æå®Œæˆï¼Œå‘ç° ${results.length} ä¸ªå°åŒº`,
          count: results.length,
          timestamp: new Date().toISOString()
        });

      } catch (error) {
        logger.error('å°åŒºæ‰«æå¤±è´¥:', error);
        
        socket.emit('scanError', {
          stage: 'scan',
          message: 'å°åŒºæ‰«æå¤±è´¥',
          error: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
        });

        callback({
          success: false,
          error: error instanceof Error ? error.message : 'å°åŒºæ‰«æå¤±è´¥',
          timestamp: new Date().toISOString()
        });
      } finally {
        cellScanInProgress = false;
      }
    });

    // è·å–æ‰«æçŠ¶æ€
    socket.on('getScanStatus', (callback) => {
      callback({
        success: true,
        data: {
          inProgress: cellScanInProgress,
          results: cellScanResults,
          count: cellScanResults.length
        },
        timestamp: new Date().toISOString()
      });
    });

    // å¯ç”¨/ç¦ç”¨ç›‘æ§
    socket.on('enableMonitoring', (enabled: boolean) => {
      try {
        if (enabled) {
          deviceMonitor.start();
          logger.info('å®¢æˆ·ç«¯å¯ç”¨è®¾å¤‡ç›‘æ§', { clientId });
        } else {
          deviceMonitor.stop();
          logger.info('å®¢æˆ·ç«¯ç¦ç”¨è®¾å¤‡ç›‘æ§', { clientId });
        }
        
        socket.emit('deviceUpdate', { monitoring: enabled });
        
      } catch (error) {
        socket.emit('error', error instanceof Error ? error.message : 'ç›‘æ§çŠ¶æ€åˆ‡æ¢å¤±è´¥');
      }
    });

    // å®¢æˆ·ç«¯æ–­å¼€è¿æ¥
    socket.on('disconnect', (reason) => {
      logger.info('å®¢æˆ·ç«¯æ–­å¼€è¿æ¥', { clientId, reason });
    });

    // é”™è¯¯å¤„ç†
    socket.on('error', (error) => {
      logger.error('Socketé”™è¯¯', { clientId, error });
    });
  });

  // å…¨å±€é”™è¯¯å¤„ç†
  io.engine.on('connection_error', (err) => {
    logger.error('Socket.IOè¿æ¥é”™è¯¯', {
      code: err.code,
      message: err.message,
      context: err.context,
      type: err.type
    });
  });

  logger.info('Socket.IOäº‹ä»¶å¤„ç†å™¨å·²è®¾ç½®å®Œæˆ');
}
