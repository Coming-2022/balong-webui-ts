import net from 'net';
import { EventEmitter } from 'events';
import { logger } from '../utils/logger';
import { DeviceConfig, SocketConfig, SignalData, LockStatus, ChipTemperature, ScanResult } from '../../types';

export class ATClient extends EventEmitter {
  private tcpSocket: net.Socket | null = null;
  private unixSocket: net.Socket | null = null;
  private isConnected: boolean = false;
  private reconnectTimer: NodeJS.Timeout | null = null;
  private deviceConfig: DeviceConfig;
  private socketConfig: SocketConfig;

  constructor(deviceConfig: DeviceConfig, socketConfig: SocketConfig) {
    super();
    this.deviceConfig = deviceConfig;
    this.socketConfig = socketConfig;
  }

  public async initialize(): Promise<void> {
    try {
      await this.connectToDevice();
      logger.info('ATå®¢æˆ·ç«¯åˆå§‹åŒ–æˆåŠŸ');
    } catch (error) {
      logger.error('ATå®¢æˆ·ç«¯åˆå§‹åŒ–å¤±è´¥:', error);
      throw error;
    }
  }

  private async connectToDevice(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.tcpSocket = new net.Socket();
      
      this.tcpSocket.connect(this.deviceConfig.serverPort, this.deviceConfig.serverIp, () => {
        this.isConnected = true;
        logger.info(`å·²è¿æ¥åˆ°è®¾å¤‡ ${this.deviceConfig.serverIp}:${this.deviceConfig.serverPort}`);
        resolve();
      });

      this.tcpSocket.on('error', (error) => {
        logger.error('TCPè¿æ¥é”™è¯¯:', error);
        this.isConnected = false;
        reject(error);
      });

      this.tcpSocket.on('close', () => {
        logger.warn('TCPè¿æ¥å·²å…³é—­');
        this.isConnected = false;
      });
    });
  }

  public async sendCommand(command: string, customTimeout?: number): Promise<string> {
    if (!this.isConnected || !this.tcpSocket) {
      throw new Error('è®¾å¤‡æœªè¿æ¥');
    }

    return new Promise((resolve, reject) => {
      const timeoutMs = customTimeout || (this.deviceConfig.timeout * 1000);
      const timeout = setTimeout(() => {
        reject(new Error(`å‘½ä»¤æ‰§è¡Œè¶…æ—¶ (${timeoutMs}ms): ${command}`));
      }, timeoutMs);

      let response = '';
      
      const onData = (data: Buffer) => {
        response += data.toString();
        
        if (response.includes('OK') || response.includes('ERROR')) {
          clearTimeout(timeout);
          this.tcpSocket?.off('data', onData);
          resolve(response);
        }
      };

      this.tcpSocket!.on('data', onData);
      this.tcpSocket!.write(command + '\r\n');
      
      logger.debug(`å‘é€ATå‘½ä»¤: ${command} (è¶…æ—¶: ${timeoutMs}ms)`);
    });
  }

  // ä¸“é—¨ç”¨äºCELLSCANçš„é•¿æ—¶é—´å‘½ä»¤æ‰§è¡Œ
  public async sendCellScanCommand(command: string, maxAttempts: number = 60): Promise<string> {
    if (!this.isConnected || !this.tcpSocket) {
      throw new Error('è®¾å¤‡æœªè¿æ¥');
    }

    logger.info(`å¼€å§‹æ‰§è¡ŒCELLSCANå‘½ä»¤: ${command}, æœ€å¤§å°è¯•æ¬¡æ•°: ${maxAttempts}`);
    
    let fullResponse = '';
    let attempts = 0;
    let completed = false;

    while (!completed && attempts < maxAttempts) {
      attempts++;
      logger.info(`CELLSCANå°è¯• ${attempts}/${maxAttempts}`);

      try {
        const response = await new Promise<string>((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new Error(`CELLSCANå‘½ä»¤è¶…æ—¶ (å°è¯• ${attempts})`));
          }, 30000);

          let currentResponse = '';
          
          const onData = (data: Buffer) => {
            currentResponse += data.toString();
            
            if (currentResponse.includes('OK') || currentResponse.includes('ERROR')) {
              clearTimeout(timeout);
              this.tcpSocket?.off('data', onData);
              resolve(currentResponse);
            }
          };

          this.tcpSocket!.on('data', onData);
          this.tcpSocket!.write(command + '\r\n');
        });

        if (response && response.trim()) {
          fullResponse += response;
          logger.debug(`CELLSCANå“åº” ${attempts}: ${response.substring(0, 200)}...`);
          
          if (response.includes('OK')) {
            logger.info(`CELLSCANå®Œæˆï¼Œå°è¯•æ¬¡æ•°: ${attempts}`);
            completed = true;
          }
        } else {
          logger.warn(`CELLSCANå°è¯• ${attempts} æœªæ”¶åˆ°å“åº”`);
        }

        if (!completed && attempts < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, 2000));
        }

      } catch (error) {
        logger.warn(`CELLSCANå°è¯• ${attempts} å¤±è´¥:`, error);
        
        if (attempts < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, 2000));
        }
      }
    }

    if (!completed) {
      throw new Error(`CELLSCANå‘½ä»¤æœªå®Œæˆï¼Œå·²å°è¯• ${attempts} æ¬¡`);
    }

    logger.info(`CELLSCANå‘½ä»¤å®Œæˆï¼Œæ€»å“åº”é•¿åº¦: ${fullResponse.length}`);
    return fullResponse;
  }

  // å…³é—­è¿æ¥
  public async close(): Promise<void> {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }

    if (this.tcpSocket) {
      this.tcpSocket.destroy();
      this.tcpSocket = null;
    }

    if (this.unixSocket) {
      this.unixSocket.destroy();
      this.unixSocket = null;
    }

    this.isConnected = false;
    logger.info('ATå®¢æˆ·ç«¯è¿æ¥å·²å…³é—­');
  }

  // è§£æä¿¡å·ä¿¡æ¯
  public parseSignalInfo(response: string): SignalData | null {
    try {
      if (!response.includes('^HCSQ:')) {
        return null;
      }

      const data = response.split('^HCSQ:')[1].split('\r\n')[0];
      const parts = data.split(',');
      
      if (parts.length >= 4) {
        const sysmode = parts[0].replace(/"/g, '').trim();
        const rsrp = parseInt(parts[1]) - 140;
        const rsrq = parseFloat(parts[2]) / 2 - 19.5;
        const sinr = parts[3] ? `${parseFloat(parts[3]) / 2 - 23} dB` : 'N/A';

        return {
          sysmode,
          rsrp,
          rsrq,
          sinr,
          timestamp: new Date().toISOString()
        };
      }

      return null;
    } catch (error) {
      logger.error('è§£æä¿¡å·ä¿¡æ¯å¤±è´¥:', error);
      return null;
    }
  }

  // è§£æèŠ¯ç‰‡æ¸©åº¦
  public parseChipTemperature(response: string): ChipTemperature | null {
    try {
      if (!response.includes('^CHIPTEMP:')) {
        return null;
      }

      const tempMatch = response.match(/\^CHIPTEMP:\s*(\d+)/);
      if (tempMatch) {
        const rawValue = parseInt(tempMatch[1]);
        return {
          temperature: `${rawValue}Â°C`,  // è½¬æ¢ä¸ºå­—ç¬¦ä¸²æ ¼å¼
          raw_value: rawValue,           // ä¿ç•™åŸå§‹æ•°å€¼
          timestamp: new Date().toISOString()
        };
      }

      return null;
    } catch (error) {
      logger.error('è§£æèŠ¯ç‰‡æ¸©åº¦å¤±è´¥:', error);
      return null;
    }
  }

  // ğŸ”§ ä¿®å¤: è§£æ5GçŠ¶æ€ - æ­£ç¡®è§£æHFREQINFOå“åº”
  public parse5GStatus(response: string): any {
    try {
      console.log('ğŸ” è§£æ5GçŠ¶æ€å“åº”:', response);
      
      if (!response) {
        console.log('âš ï¸ å“åº”ä¸ºç©º');
        return this.getMock5GStatus();
      }

      // æ£€æŸ¥æ˜¯å¦åŒ…å«HFREQINFOä¿¡æ¯
      if (!response.includes('HFREQINFO') && !response.includes('^HFREQINFO')) {
        console.log('âš ï¸ å“åº”ä¸­æœªæ‰¾åˆ°HFREQINFOä¿¡æ¯ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®');
        console.log('ğŸ“ å®é™…å“åº”å†…å®¹:', response.substring(0, 200));
        return this.getMock5GStatus();
      }

      // è§£æHFREQINFOå“åº”
      const lines = response.split('\n');
      let nrCount = 0;
      let lteCount = 0;
      const bands = [];
      
      for (const line of lines) {
        const trimmedLine = line.trim();
        
        // åŒ¹é… ^HFREQINFO: æ ¼å¼
        if (trimmedLine.includes('HFREQINFO:')) {
          console.log('ğŸ“¡ æ‰¾åˆ°HFREQINFOè¡Œ:', trimmedLine);
          
          // å°è¯•è§£æä¸åŒæ ¼å¼çš„HFREQINFOå“åº”
          const match = trimmedLine.match(/HFREQINFO:\s*"(\w+)"[,\s]*(\d+)?/);
          if (match) {
            const technology = match[1];
            const band = match[2];
            
            if (technology === 'NR' || technology === '5G') {
              nrCount++;
              if (band) bands.push('n' + band);
            } else if (technology === 'LTE' || technology === '4G') {
              lteCount++;
              if (band) bands.push('b' + band);
            }
          }
        }
      }
      
      // å¦‚æœæ²¡æœ‰è§£æåˆ°æ•°æ®ï¼Œä½†æœ‰HFREQINFOå“åº”ï¼Œå°è¯•å…¶ä»–è§£ææ–¹æ³•
      if (nrCount === 0 && lteCount === 0) {
        console.log('âš ï¸ æ ‡å‡†è§£æå¤±è´¥ï¼Œå°è¯•å¤‡ç”¨è§£ææ–¹æ³•');
        
        // ç®€å•æ£€æŸ¥æ˜¯å¦åŒ…å«5Gç›¸å…³å…³é”®è¯
        const responseUpper = response.toUpperCase();
        if (responseUpper.includes('NR') || responseUpper.includes('5G')) {
          nrCount = 1;
          bands.push('n78'); // é»˜è®¤é¢‘æ®µ
        } else if (responseUpper.includes('LTE') || responseUpper.includes('4G')) {
          lteCount = 1;
          bands.push('b3'); // é»˜è®¤é¢‘æ®µ
        }
      }
      
      const result = {
        nr_count: nrCount,
        lte_count: lteCount,
        bands: bands.length > 0 ? bands : ['n78'], // é»˜è®¤é¢‘æ®µ
        status: nrCount > 0 ? 'connected' : (lteCount > 0 ? 'lte_only' : 'disconnected'),
        raw_response: response,
        timestamp: new Date().toISOString()
      };
      
      console.log('âœ… 5GçŠ¶æ€è§£ææˆåŠŸ:', result);
      return result;
      
    } catch (error) {
      console.error('âŒ è§£æ5GçŠ¶æ€å¤±è´¥:', error);
      logger.error('è§£æ5GçŠ¶æ€å¤±è´¥:', error);
      return this.getMock5GStatus();
    }
  }

  // ğŸ”§ æ–°å¢: è·å–æ¨¡æ‹Ÿ5GçŠ¶æ€æ•°æ®
  private getMock5GStatus(): any {
    return {
      nr_count: 1,
      lte_count: 0,
      bands: ['n78'],
      status: 'connected',
      mock: true,
      message: 'ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ® - è®¾å¤‡å¯èƒ½æœªè¿æ¥æˆ–å‘½ä»¤ä¸æ”¯æŒ',
      timestamp: new Date().toISOString()
    };
  }

  // è§£æé”å®šçŠ¶æ€
  public parseLockStatus(response: string): LockStatus | null {
    try {
      if (!response.includes('^NRFREQLOCK:')) {
        return {
          status: 'unlocked' as const,
          info: 'None',
          timestamp: new Date().toISOString()
        };
      }

      return {
        status: 'locked' as const,
        info: response,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      logger.error('è§£æé”å®šçŠ¶æ€å¤±è´¥:', error);
      return null;
    }
  }

  // è§£æå°åŒºæ‰«æç»“æœ
  public parseCellScanResults(response: string): ScanResult[] {
    try {
      const results: ScanResult[] = [];
      
      if (!response || !response.includes('^CELLSCAN:')) {
        logger.warn('æ‰«æå“åº”ä¸­æœªæ‰¾åˆ°CELLSCANæ•°æ®');
        return results;
      }

      // åˆ†å‰²å“åº”ä¸ºè¡Œ
      const lines = response.split('\n');
      
      for (const line of lines) {
        if (line.includes('^CELLSCAN:')) {
          try {
            // è§£æCELLSCANè¡Œæ ¼å¼: ^CELLSCAN: rat,plmn,freq,pci,band,lac,scs,rsrp,rsrq,sinr,lte_sinr
            const data = line.split('^CELLSCAN:')[1].trim();
            const parts = data.split(',');
            
            if (parts.length >= 11) {
              const scanResult: ScanResult = {
                rat: parts[0].replace(/"/g, '').trim(),
                plmn: parts[1].replace(/"/g, '').trim(),
                freq: parseInt(parts[2]) || 0,
                pci: parseInt(parts[3]) || 0,
                band: parseInt(parts[4]) || 0,
                lac: parseInt(parts[5]) || 0,
                scs: parts[6].replace(/"/g, '').trim(),
                rsrp: parseInt(parts[7]) || 0,
                rsrq: parseInt(parts[8]) || 0,
                sinr: parseInt(parts[9]) || 0,
                lte_sinr: parseInt(parts[10]) || 0,
                timestamp: new Date().toISOString()
              };
              
              results.push(scanResult);
            }
          } catch (parseError) {
            logger.warn('è§£æå•ä¸ªCELLSCANè¡Œå¤±è´¥:', parseError, 'è¡Œå†…å®¹:', line);
          }
        }
      }
      
      logger.info(`æˆåŠŸè§£æ ${results.length} ä¸ªå°åŒºæ‰«æç»“æœ`);
      return results;
      
    } catch (error) {
      logger.error('è§£æå°åŒºæ‰«æç»“æœå¤±è´¥:', error);
      return [];
    }
  }

  public get connected(): boolean {
    return this.isConnected;
  }
}
