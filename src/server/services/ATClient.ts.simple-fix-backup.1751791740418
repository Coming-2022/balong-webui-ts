import net from 'net';
import { EventEmitter } from 'events';
import { logger } from '../utils/logger';
import { DeviceConfig, SocketConfig, SignalData, LockStatus, ChipTemperature, ScanResult } from '../../types';

export class ATClient extends EventEmitter {
  private tcpSocket: net.Socket | null = null;
  private unixSocket: net.Socket | null = null;
  private isConnected: boolean = false;
  private reconnectTimer: NodeJS.Timeout | null = null;
  private deviceConfig: DeviceConfig;
  private socketConfig: SocketConfig;

  constructor(deviceConfig: DeviceConfig, socketConfig: SocketConfig) {
    super();
    this.deviceConfig = deviceConfig;
    this.socketConfig = socketConfig;
  }

  public async initialize(): Promise<void> {
    try {
      await this.connectToDevice();
      logger.info('ATå®¢æˆ·ç«¯åˆå§‹åŒ–æˆåŠŸ');
    } catch (error) {
      logger.error('ATå®¢æˆ·ç«¯åˆå§‹åŒ–å¤±è´¥:', error);
      throw error;
    }
  }

  private async connectToDevice(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.tcpSocket = new net.Socket();
      
      this.tcpSocket.connect(this.deviceConfig.serverPort, this.deviceConfig.serverIp, () => {
        this.isConnected = true;
        logger.info(`å·²è¿æ¥åˆ°è®¾å¤‡ ${this.deviceConfig.serverIp}:${this.deviceConfig.serverPort}`);
        resolve();
      });

      this.tcpSocket.on('error', (error) => {
        logger.error('TCPè¿æ¥é”™è¯¯:', error);
        this.isConnected = false;
        reject(error);
      });

      this.tcpSocket.on('close', () => {
        logger.warn('TCPè¿æ¥å·²å…³é—­');
        this.isConnected = false;
      });
    });
  }

  public async sendCommand(command: string, customTimeout?: number): Promise<string> {
    if (!this.isConnected || !this.tcpSocket) {
      throw new Error('è®¾å¤‡æœªè¿æ¥');
    }

    return new Promise((resolve, reject) => {
      const timeoutMs = customTimeout || (this.deviceConfig.timeout * 1000);
      const timeout = setTimeout(() => {
        reject(new Error(`å‘½ä»¤æ‰§è¡Œè¶…æ—¶ (${timeoutMs}ms): ${command}`));
      }, timeoutMs);

      let response = '';
      
      const onData = (data: Buffer) => {
        response += data.toString();
        
        if (response.includes('OK') || response.includes('ERROR')) {
          clearTimeout(timeout);
          this.tcpSocket?.off('data', onData);
          resolve(response);
        }
      };

      this.tcpSocket!.on('data', onData);
      this.tcpSocket!.write(command + '\r\n');
      
      logger.debug(`å‘é€ATå‘½ä»¤: ${command} (è¶…æ—¶: ${timeoutMs}ms)`);
    });
  }

  // ä¸“é—¨ç”¨äºCELLSCANçš„é•¿æ—¶é—´å‘½ä»¤æ‰§è¡Œ
  public async sendCellScanCommand(command: string, maxAttempts: number = 60): Promise<string> {
    if (!this.isConnected || !this.tcpSocket) {
      throw new Error('è®¾å¤‡æœªè¿æ¥');
    }

    logger.info(`å¼€å§‹æ‰§è¡ŒCELLSCANå‘½ä»¤: ${command}, æœ€å¤§å°è¯•æ¬¡æ•°: ${maxAttempts}`);
    
    let fullResponse = '';
    let attempts = 0;
    let completed = false;

    while (!completed && attempts < maxAttempts) {
      attempts++;
      logger.info(`CELLSCANå°è¯• ${attempts}/${maxAttempts}`);

      try {
        const response = await new Promise<string>((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new Error(`CELLSCANå‘½ä»¤è¶…æ—¶ (å°è¯• ${attempts})`));
          }, 30000);

          let currentResponse = '';
          
          const onData = (data: Buffer) => {
            currentResponse += data.toString();
            
            if (currentResponse.includes('OK') || currentResponse.includes('ERROR')) {
              clearTimeout(timeout);
              this.tcpSocket?.off('data', onData);
              resolve(currentResponse);
            }
          };

          this.tcpSocket!.on('data', onData);
          this.tcpSocket!.write(command + '\r\n');
        });

        if (response && response.trim()) {
          fullResponse += response;
          logger.debug(`CELLSCANå“åº” ${attempts}: ${response.substring(0, 200)}...`);
          
          if (response.includes('OK')) {
            logger.info(`CELLSCANå®Œæˆï¼Œå°è¯•æ¬¡æ•°: ${attempts}`);
            completed = true;
          }
        } else {
          logger.warn(`CELLSCANå°è¯• ${attempts} æœªæ”¶åˆ°å“åº”`);
        }

        if (!completed && attempts < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, 2000));
        }

      } catch (error) {
        logger.warn(`CELLSCANå°è¯• ${attempts} å¤±è´¥:`, error);
        
        if (attempts < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, 2000));
        }
      }
    }

    if (!completed) {
      throw new Error(`CELLSCANå‘½ä»¤æœªå®Œæˆï¼Œå·²å°è¯• ${attempts} æ¬¡`);
    }

    logger.info(`CELLSCANå‘½ä»¤å®Œæˆï¼Œæ€»å“åº”é•¿åº¦: ${fullResponse.length}`);
    return fullResponse;
  }

  // å…³é—­è¿æ¥
  public async close(): Promise<void> {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }

    if (this.tcpSocket) {
      this.tcpSocket.destroy();
      this.tcpSocket = null;
    }

    if (this.unixSocket) {
      this.unixSocket.destroy();
      this.unixSocket = null;
    }

    this.isConnected = false;
    logger.info('ATå®¢æˆ·ç«¯è¿æ¥å·²å…³é—­');
  }

  // è§£æä¿¡å·ä¿¡æ¯
  public parseSignalInfo(response: string): SignalData | null {
    try {
      if (!response.includes('^HCSQ:')) {
        return null;
      }

      const data = response.split('^HCSQ:')[1].split('\r\n')[0];
      const parts = data.split(',');
      
      if (parts.length >= 4) {
        const sysmode = parts[0].replace(/"/g, '').trim();
        const rsrp = parseInt(parts[1]) - 140;
        const rsrq = parseFloat(parts[2]) / 2 - 19.5;
        const sinr = parts[3] ? `${parseFloat(parts[3]) / 2 - 23} dB` : 'N/A';

        return {
          sysmode,
          rsrp,
          rsrq,
          sinr,
          timestamp: new Date().toISOString()
        };
      }

      return null;
    } catch (error) {
      logger.error('è§£æä¿¡å·ä¿¡æ¯å¤±è´¥:', error);
      return null;
    }
  }

  // è§£æèŠ¯ç‰‡æ¸©åº¦
  public parseChipTemperature(response: string): ChipTemperature | null {
    try {
      if (!response.includes('^CHIPTEMP:')) {
        return null;
      }

      const tempMatch = response.match(/\^CHIPTEMP:\s*(\d+)/);
      if (tempMatch) {
        const rawValue = parseInt(tempMatch[1]);
        return {
          temperature: `${rawValue}Â°C`,  // è½¬æ¢ä¸ºå­—ç¬¦ä¸²æ ¼å¼
          raw_value: rawValue,           // ä¿ç•™åŸå§‹æ•°å€¼
          timestamp: new Date().toISOString()
        };
      }

      return null;
    } catch (error) {
      logger.error('è§£æèŠ¯ç‰‡æ¸©åº¦å¤±è´¥:', error);
      return null;
    }
  }

  // ğŸ”§ ä¿®å¤: è§£æ5GçŠ¶æ€ - æ­£ç¡®è§£æHFREQINFOå“åº”
  public parse5GStatus(response: string): any {
    try {
      console.log('ğŸ” è§£æ5GçŠ¶æ€å“åº”:', response);
      
      if (!response) {
        console.log('âš ï¸ å“åº”ä¸ºç©º');
        return this.getMock5GStatus();
      }

      // æ£€æŸ¥æ˜¯å¦åŒ…å«HFREQINFOä¿¡æ¯
      if (!response.includes('HFREQINFO') && !response.includes('^HFREQINFO')) {
        console.log('âš ï¸ å“åº”ä¸­æœªæ‰¾åˆ°HFREQINFOä¿¡æ¯ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®');
        console.log('ğŸ“ å®é™…å“åº”å†…å®¹:', response.substring(0, 200));
        return this.getMock5GStatus();
      }

      // ğŸ”§ ä¿®å¤: è§£æHFREQINFOå“åº” - æ­£ç¡®å¤„ç†è½½æ³¢ä¿¡æ¯æ ¼å¼
      const lines = response.split('\n');
      let nrCount: number = 0;
      let lteCount: number = 0;
      const bands: string[] = [];
      const carrierInfo = [];
      
      for (const line of lines) {
        const trimmedLine = line.trim();
        
        // åŒ¹é… ^HFREQINFO: æ ¼å¼
        if (trimmedLine.includes('HFREQINFO:')) {
          console.log('ğŸ“¡ æ‰¾åˆ°HFREQINFOè¡Œ:', trimmedLine);
          
          // è§£æHFREQINFOå“åº”æ ¼å¼: ^HFREQINFO: proa,sysmode,band1,arfcn1,freq1,bw1,band2,arfcn2,freq2,bw2,...
          const dataStr = trimmedLine.replace(/^.*HFREQINFO:\s*/, '');
          const values = dataStr.split(',').map(v => v.trim());
          
          console.log('ğŸ“Š HFREQINFOæ•°æ®å€¼:', values);
          
          if (values.length >= 2) {
            const proa = parseInt(values[0]) || 0;  // ä¸»è½½æ³¢çŠ¶æ€
            const sysmode = parseInt(values[1]) || 0; // ç³»ç»Ÿæ¨¡å¼
            
            console.log('ğŸ“‹ è§£æå‚æ•°: proa=' + proa + ', sysmode=' + sysmode);
            
            // è§£æè½½æ³¢ä¿¡æ¯ (ä»ç¬¬3ä¸ªå‚æ•°å¼€å§‹ï¼Œæ¯4ä¸ªå‚æ•°ä¸ºä¸€ç»„: band,arfcn,freq,bw)
            const carrierData = values.slice(2);
            let carrierIndex = 0;
            
            while (carrierIndex + 3 < carrierData.length) {
              const band = parseInt(carrierData[carrierIndex]);
              const arfcn = parseInt(carrierData[carrierIndex + 1]);
              const freq = parseInt(carrierData[carrierIndex + 2]);
              const bw = parseInt(carrierData[carrierIndex + 3]);
              
              if (band && arfcn) {
                // æ ¹æ®é¢‘æ®µåˆ¤æ–­æ˜¯5G NRè¿˜æ˜¯LTE
                if (band >= 77 && band <= 79) {
                  // n77, n78, n79 æ˜¯5Gé¢‘æ®µ
                  nrCount++;
                  bands.push('n' + band);
                  carrierInfo.push({
                    type: 'NR',
                    band: 'n' + band,
                    arfcn: arfcn,
                    freq: freq,
                    bandwidth: bw
                  });
                } else if (band >= 1 && band <= 50) {
                  // 1-50 é€šå¸¸æ˜¯LTEé¢‘æ®µ
                  lteCount++;
                  bands.push('b' + band);
                  carrierInfo.push({
                    type: 'LTE',
                    band: 'b' + band,
                    arfcn: arfcn,
                    freq: freq,
                    bandwidth: bw
                  });
                } else {
                  // å…¶ä»–é¢‘æ®µï¼Œæ ¹æ®é¢‘ç‡èŒƒå›´åˆ¤æ–­
                  if (freq > 3000000) {
                    // é«˜é¢‘é€šå¸¸æ˜¯5G
                    nrCount++;
                    bands.push('n' + band);
                    carrierInfo.push({
                      type: 'NR',
                      band: 'n' + band,
                      arfcn: arfcn,
                      freq: freq,
                      bandwidth: bw
                    });
                  } else {
                    // ä½é¢‘é€šå¸¸æ˜¯LTE
                    lteCount++;
                    bands.push('b' + band);
                    carrierInfo.push({
                      type: 'LTE',
                      band: 'b' + band,
                      arfcn: arfcn,
                      freq: freq,
                      bandwidth: bw
                    });
                  }
                }
                
                console.log('ğŸ“¡ è½½æ³¢ä¿¡æ¯: band=' + band + ', arfcn=' + arfcn + ', freq=' + freq + ', bw=' + bw);
              }
              
              carrierIndex += 4;
            }
            
            console.log('ğŸ“Š è½½æ³¢ç»Ÿè®¡: NR=' + nrCount + ', LTE=' + lteCount);
            console.log('ğŸ“‹ é¢‘æ®µåˆ—è¡¨:', bands);
          }
        }
      }
      
      // ğŸ”§ ä¿®å¤: æ”¹è¿›å¤‡ç”¨è§£ææ–¹æ³•
      if (nrCount === 0 && lteCount === 0) {
        console.log('âš ï¸ æ ‡å‡†è§£æå¤±è´¥ï¼Œå°è¯•å¤‡ç”¨è§£ææ–¹æ³•');
        
        // æ£€æŸ¥å“åº”ä¸­æ˜¯å¦åŒ…å«é¢‘æ®µä¿¡æ¯
        const responseStr = response.toString();
        
        // æŸ¥æ‰¾n78ç­‰5Gé¢‘æ®µ
        const nrBandMatches = responseStr.match(/\b(n?78|n?79|n?77)\b/gi);
        if (nrBandMatches) {
          nrCount = nrBandMatches.length;
          nrBandMatches.forEach(match => {
            const band = match.replace(/^n?/, 'n');
            if (!bands.includes(band)) bands.push(band);
          });
          console.log('ğŸ” å¤‡ç”¨è§£ææ‰¾åˆ°5Gé¢‘æ®µ:', nrBandMatches);
        }
        
        // æŸ¥æ‰¾LTEé¢‘æ®µ
        const lteBandMatches = responseStr.match(/\b([1-9]|[1-4][0-9]|50)\b/g);
        if (lteBandMatches && nrCount === 0) {
          // åªæœ‰åœ¨æ²¡æœ‰æ‰¾åˆ°5Gé¢‘æ®µæ—¶æ‰è®¤ä¸ºæ˜¯LTE
          lteCount = Math.min(lteBandMatches.length, 3); // é™åˆ¶LTEè½½æ³¢æ•°
          lteBandMatches.slice(0, 3).forEach(match => {
            const band = 'b' + match;
            if (!bands.includes(band)) bands.push(band);
          });
          console.log('ğŸ” å¤‡ç”¨è§£ææ‰¾åˆ°LTEé¢‘æ®µ:', lteBandMatches.slice(0, 3));
        }
        
        // å¦‚æœä»ç„¶æ²¡æœ‰æ‰¾åˆ°ï¼Œä½¿ç”¨é»˜è®¤å€¼
        if (nrCount === 0 && lteCount === 0) {
          // æ ¹æ®HFREQINFOå“åº”çš„å­˜åœ¨æ¨æ–­è‡³å°‘æœ‰ä¸€ä¸ªè½½æ³¢
          if (responseStr.includes('HFREQINFO:')) {
            nrCount = 1;
            bands.push('n78');
            console.log('ğŸ” å¤‡ç”¨è§£æä½¿ç”¨é»˜è®¤5Gé…ç½®');
          }
        }
      }
      
      const result = {
        nr_count: nrCount,
        lte_count: lteCount,
        bands: bands.length > 0 ? bands : ['n78'], // é»˜è®¤é¢‘æ®µ
        status: nrCount > 0 ? 'connected' : (lteCount > 0 ? 'lte_only' : 'disconnected'),
        raw_response: response,
        timestamp: new Date().toISOString()
      };
      
      console.log('âœ… 5GçŠ¶æ€è§£ææˆåŠŸ:', result);
      return result;
      
    } catch (error) {
      console.error('âŒ è§£æ5GçŠ¶æ€å¤±è´¥:', error);
      logger.error('è§£æ5GçŠ¶æ€å¤±è´¥:', error);
      return this.getMock5GStatus();
    }
  }

  // ğŸ”§ æ–°å¢: è·å–æ¨¡æ‹Ÿ5GçŠ¶æ€æ•°æ®
  private getMock5GStatus(): any {
    return {
      nr_count: 1,
      lte_count: 0,
      bands: ['n78'],
      status: 'connected',
      mock: true,
      message: 'ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ® - è®¾å¤‡å¯èƒ½æœªè¿æ¥æˆ–å‘½ä»¤ä¸æ”¯æŒ',
      timestamp: new Date().toISOString()
    };
  }

  // è§£æé”å®šçŠ¶æ€
  public parseLockStatus(response: string): LockStatus | null {
    try {
      if (!response.includes('^NRFREQLOCK:')) {
        return {
          status: 'unlocked' as const,
          info: 'None',
          timestamp: new Date().toISOString()
        };
      }

      return {
        status: 'locked' as const,
        info: response,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      logger.error('è§£æé”å®šçŠ¶æ€å¤±è´¥:', error);
      return null;
    }
  }

  // è§£æå°åŒºæ‰«æç»“æœ
  public parseCellScanResults(response: string): ScanResult[] {
    try {
      const results: ScanResult[] = [];
      
      if (!response || !response.includes('^CELLSCAN:')) {
        logger.warn('æ‰«æå“åº”ä¸­æœªæ‰¾åˆ°CELLSCANæ•°æ®');
        return results;
      }

      // åˆ†å‰²å“åº”ä¸ºè¡Œ
      const lines = response.split('\n');
      
      for (const line of lines) {
        if (line.includes('^CELLSCAN:')) {
          try {
            // è§£æCELLSCANè¡Œæ ¼å¼: ^CELLSCAN: rat,plmn,freq,pci,band,lac,scs,rsrp,rsrq,sinr,lte_sinr
            const data = line.split('^CELLSCAN:')[1].trim();
            const parts = data.split(',');
            
            if (parts.length >= 11) {
              const scanResult: ScanResult = {
                rat: parts[0].replace(/"/g, '').trim(),
                plmn: parts[1].replace(/"/g, '').trim(),
                freq: parseInt(parts[2]) || 0,
                pci: parseInt(parts[3]) || 0,
                band: parseInt(parts[4]) || 0,
                lac: parseInt(parts[5]) || 0,
                scs: parts[6].replace(/"/g, '').trim(),
                rsrp: parseInt(parts[7]) || 0,
                rsrq: parseInt(parts[8]) || 0,
                sinr: parseInt(parts[9]) || 0,
                lte_sinr: parseInt(parts[10]) || 0,
                timestamp: new Date().toISOString()
              };
              
              results.push(scanResult);
            }
          } catch (parseError) {
            logger.warn('è§£æå•ä¸ªCELLSCANè¡Œå¤±è´¥:', parseError, 'è¡Œå†…å®¹:', line);
          }
        }
      }
      
      logger.info(`æˆåŠŸè§£æ ${results.length} ä¸ªå°åŒºæ‰«æç»“æœ`);
      return results;
      
    } catch (error) {
      logger.error('è§£æå°åŒºæ‰«æç»“æœå¤±è´¥:', error);
      return [];
    }
  }

  public get connected(): boolean {
    return this.isConnected;
  }
}
