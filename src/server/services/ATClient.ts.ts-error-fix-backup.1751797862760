import net from 'net';
import { EventEmitter } from 'events';
import { logger } from '../utils/logger';
import { DeviceConfig, SocketConfig, SignalData, LockStatus, ChipTemperature, ScanResult } from '../../types';

export class ATClient extends EventEmitter {
  private tcpSocket: net.Socket | null = null;
  private unixSocket: net.Socket | null = null;
  private isConnected: boolean = false;
  private reconnectTimer: NodeJS.Timeout | null = null;
  private deviceConfig: DeviceConfig;
  private socketConfig: SocketConfig;

  constructor(deviceConfig: DeviceConfig, socketConfig: SocketConfig) {
    super();
    this.deviceConfig = deviceConfig;
    this.socketConfig = socketConfig;
  }

  public async initialize(): Promise<void> {
    try {
      await this.connectToDevice();
      logger.info('ATå®¢æˆ·ç«¯åˆå§‹åŒ–æˆåŠŸ');
    } catch (error) {
      logger.error('ATå®¢æˆ·ç«¯åˆå§‹åŒ–å¤±è´¥:', error);
      throw error;
    }
  }

  private async connectToDevice(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.tcpSocket = new net.Socket();
      
      this.tcpSocket.connect(this.deviceConfig.serverPort, this.deviceConfig.serverIp, () => {
        this.isConnected = true;
        logger.info(`å·²è¿æ¥åˆ°è®¾å¤‡ ${this.deviceConfig.serverIp}:${this.deviceConfig.serverPort}`);
        resolve();
      });

      this.tcpSocket.on('error', (error) => {
        logger.error('TCPè¿æ¥é”™è¯¯:', error.message);
        this.isConnected = false;
        
        // ğŸ”§ è¿æ¥é”™è¯¯æ—¶æ¸…ç†socket
        if (this.tcpSocket) {
          this.tcpSocket.destroy();
          this.tcpSocket = null;
        }
        
        reject(error);
      });

      this.tcpSocket.on('close', () => {
        logger.warn('TCPè¿æ¥å·²å…³é—­');
        this.isConnected = false;
        
        // ğŸ”§ æ¸…ç†socketå¼•ç”¨
        this.tcpSocket = null;
        
        console.log('ğŸ”„ è¿æ¥å·²æ–­å¼€ï¼Œä¸‹æ¬¡ATå‘½ä»¤å°†è‡ªåŠ¨é‡è¿');
      });
    });
  }

  public async sendCommand(command: string, customTimeout?: number): Promise<string> {
    // ğŸ”§ è¿æ¥æ¢å¤æœºåˆ¶
    if (!this.isConnected || !this.tcpSocket) {
      console.log('ğŸ”„ æ£€æµ‹åˆ°è¿æ¥æ–­å¼€ï¼Œå°è¯•é‡æ–°è¿æ¥...');
      try {
        await this.connect();
        console.log('âœ… è¿æ¥å·²æ¢å¤');
      } catch (error) {
        console.error('âŒ è¿æ¥æ¢å¤å¤±è´¥:', error);
        throw new Error('è®¾å¤‡æœªè¿æ¥ï¼Œè¿æ¥æ¢å¤å¤±è´¥: ' + error.message);
      }
    }
    
    // ğŸ”§ æ£€æµ‹é‡å¯å‘½ä»¤ï¼Œç»™å‡ºæç¤º
    const restartCommands = ['AT+CFUN=1,1', 'AT+CFUN=0,1', 'AT^RESET'];
    if (restartCommands.some(cmd => command.includes(cmd))) {
      console.log('âš ï¸ æ£€æµ‹åˆ°é‡å¯å‘½ä»¤ï¼ŒèŠ¯ç‰‡å°†é‡å¯ï¼Œåç»­å‘½ä»¤å¯èƒ½éœ€è¦ç­‰å¾…è¿æ¥æ¢å¤');
    }

    return new Promise((resolve, reject) => {
      const timeoutMs = customTimeout || (this.deviceConfig.timeout * 1000);
      const timeout = setTimeout(() => {
        reject(new Error(`å‘½ä»¤æ‰§è¡Œè¶…æ—¶ (${timeoutMs}ms): ${command}`));
      }, timeoutMs);

      let response = '';
      
      const onData = (data: Buffer) => {
        response += data.toString();
        
        if (response.includes('OK') || response.includes('ERROR')) {
          clearTimeout(timeout);
          this.tcpSocket?.off('data', onData);
          resolve(response);
        }
      };

      this.tcpSocket!.on('data', onData);
      this.tcpSocket!.write(command + '\r\n');
      
      logger.debug(`å‘é€ATå‘½ä»¤: ${command} (è¶…æ—¶: ${timeoutMs}ms)`);
    });
  }

  // ä¸“é—¨ç”¨äºCELLSCANçš„é•¿æ—¶é—´å‘½ä»¤æ‰§è¡Œ
  public async sendCellScanCommand(command: string, maxAttempts: number = 60): Promise<string> {
    if (!this.isConnected || !this.tcpSocket) {
      throw new Error('è®¾å¤‡æœªè¿æ¥');
    }

    logger.info(`å¼€å§‹æ‰§è¡ŒCELLSCANå‘½ä»¤: ${command}, æœ€å¤§å°è¯•æ¬¡æ•°: ${maxAttempts}`);
    
    let fullResponse = '';
    let attempts = 0;
    let completed = false;

    while (!completed && attempts < maxAttempts) {
      attempts++;
      logger.info(`CELLSCANå°è¯• ${attempts}/${maxAttempts}`);

      try {
        const response = await new Promise<string>((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new Error(`CELLSCANå‘½ä»¤è¶…æ—¶ (å°è¯• ${attempts})`));
          }, 30000);

          let currentResponse = '';
          
          const onData = (data: Buffer) => {
            currentResponse += data.toString();
            
            if (currentResponse.includes('OK') || currentResponse.includes('ERROR')) {
              clearTimeout(timeout);
              this.tcpSocket?.off('data', onData);
              resolve(currentResponse);
            }
          };

          this.tcpSocket!.on('data', onData);
          this.tcpSocket!.write(command + '\r\n');
        });

        if (response && response.trim()) {
          fullResponse += response;
          logger.debug(`CELLSCANå“åº” ${attempts}: ${response.substring(0, 200)}...`);
          
          if (response.includes('OK')) {
            logger.info(`CELLSCANå®Œæˆï¼Œå°è¯•æ¬¡æ•°: ${attempts}`);
            completed = true;
          }
        } else {
          logger.warn(`CELLSCANå°è¯• ${attempts} æœªæ”¶åˆ°å“åº”`);
        }

        if (!completed && attempts < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, 2000));
        }

      } catch (error) {
        logger.warn(`CELLSCANå°è¯• ${attempts} å¤±è´¥:`, error);
        
        if (attempts < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, 2000));
        }
      }
    }

    if (!completed) {
      throw new Error(`CELLSCANå‘½ä»¤æœªå®Œæˆï¼Œå·²å°è¯• ${attempts} æ¬¡`);
    }

    logger.info(`CELLSCANå‘½ä»¤å®Œæˆï¼Œæ€»å“åº”é•¿åº¦: ${fullResponse.length}`);
    return fullResponse;
  }

  // å…³é—­è¿æ¥
  public async close(): Promise<void> {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }

    if (this.tcpSocket) {
      this.tcpSocket.destroy();
      this.tcpSocket = null;
    }

    if (this.unixSocket) {
      this.unixSocket.destroy();
      this.unixSocket = null;
    }

    this.isConnected = false;
    logger.info('ATå®¢æˆ·ç«¯è¿æ¥å·²å…³é—­');
  }

  // è§£æä¿¡å·ä¿¡æ¯
  public parseSignalInfo(response: string): SignalData | null {
    try {
      if (!response.includes('^HCSQ:')) {
        return null;
      }

      const data = response.split('^HCSQ:')[1].split('\r\n')[0];
      const parts = data.split(',');
      
      if (parts.length >= 4) {
        const sysmode = parts[0].replace(/"/g, '').trim();
        const rsrp = parseInt(parts[1]) - 140;
        const rsrq = parseFloat(parts[2]) / 2 - 19.5;
        const sinr = parts[3] ? `${parseFloat(parts[3]) / 2 - 23} dB` : 'N/A';

        return {
          sysmode,
          rsrp,
          rsrq,
          sinr,
          timestamp: new Date().toISOString()
        };
      }

      return null;
    } catch (error) {
      logger.error('è§£æä¿¡å·ä¿¡æ¯å¤±è´¥:', error);
      return null;
    }
  }

  // è§£æèŠ¯ç‰‡æ¸©åº¦
  public parseChipTemperature(response: string): ChipTemperature | null {
    try {
      if (!response.includes('^CHIPTEMP:')) {
        return null;
      }

      const tempMatch = response.match(/\^CHIPTEMP:\s*(\d+)/);
      if (tempMatch) {
        const rawValue = parseInt(tempMatch[1]);
        return {
          temperature: `${rawValue}Â°C`,  // è½¬æ¢ä¸ºå­—ç¬¦ä¸²æ ¼å¼
          raw_value: rawValue,           // ä¿ç•™åŸå§‹æ•°å€¼
          timestamp: new Date().toISOString()
        };
      }

      return null;
    } catch (error) {
      logger.error('è§£æèŠ¯ç‰‡æ¸©åº¦å¤±è´¥:', error);
      return null;
    }
  }

  // ğŸ”§ ä¿®å¤: è§£æ5GçŠ¶æ€ - æ­£ç¡®è§£æHFREQINFOå“åº”
  public parse5GStatus(response: string): any {
    try {
      console.log('ğŸ” è§£æ5GçŠ¶æ€å“åº”:', response);
      
      if (!response) {
        console.log('âš ï¸ å“åº”ä¸ºç©º');
        return this.getMock5GStatus();
      }

      // æ£€æŸ¥æ˜¯å¦åŒ…å«HFREQINFOä¿¡æ¯
      if (!response.includes('HFREQINFO') && !response.includes('^HFREQINFO')) {
        console.log('âš ï¸ å“åº”ä¸­æœªæ‰¾åˆ°HFREQINFOä¿¡æ¯ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®');
        console.log('ğŸ“ å®é™…å“åº”å†…å®¹:', response.substring(0, 200));
        return this.getMock5GStatus();
      }

      // ğŸ”§ ä¿®å¤: è§£æHFREQINFOå“åº” - æ­£ç¡®å¤„ç†è½½æ³¢ä¿¡æ¯æ ¼å¼
      const lines = response.split('\n');
      let nrCount: number = 0;
      let lteCount: number = 0;
      const bands: string[] = [];
      const carrierInfo = [];
      
      for (const line of lines) {
        const trimmedLine = line.trim();
        
        // åŒ¹é… ^HFREQINFO: æ ¼å¼
        if (trimmedLine.includes('HFREQINFO:')) {
          console.log('ğŸ“¡ æ‰¾åˆ°HFREQINFOè¡Œ:', trimmedLine);
          
          // è§£æHFREQINFOå“åº”æ ¼å¼: ^HFREQINFO: proa,sysmode,band1,arfcn1,freq1,bw1,band2,arfcn2,freq2,bw2,...
          const dataStr = trimmedLine.replace(/^.*HFREQINFO:\s*/, '');
          const values = dataStr.split(',').map(v => v.trim());
          
          console.log('ğŸ“Š HFREQINFOæ•°æ®å€¼:', values);
          
          if (values.length >= 2) {
            const proa = parseInt(values[0]) || 0;  // ä¸»è½½æ³¢çŠ¶æ€
            const sysmode = parseInt(values[1]) || 0; // ç³»ç»Ÿæ¨¡å¼
            
            console.log('ğŸ“‹ è§£æå‚æ•°: proa=' + proa + ', sysmode=' + sysmode);
            
            // ğŸ”§ ä¿®å¤: æ­£ç¡®è§£æè½½æ³¢èšåˆä¿¡æ¯
            // HFREQINFOæ ¼å¼: proa,sysmode,band1,arfcn1,freq1,bw1,band2,arfcn2,freq2,bw2,...
            const carrierData = values.slice(2);
            console.log('ğŸ” è½½æ³¢æ•°æ®:', carrierData);
            
            // æ‰¾åˆ°æ‰€æœ‰çš„é¢‘æ®µä½ç½®ï¼ˆé¢‘æ®µå·é€šå¸¸æ˜¯1-100çš„å°æ•°å­—ï¼‰
            const bandPositions = [];
            for (let i = 0; i < carrierData.length; i++) {
              const val = parseInt(carrierData[i]);
              // é¢‘æ®µå·ç‰¹å¾ï¼š1-100ä¹‹é—´çš„æ•°å­—ï¼Œä¸”åé¢è·Ÿç€ARFCNï¼ˆå¤§æ•°å­—ï¼‰
              if (val >= 1 && val <= 100 && i + 1 < carrierData.length) {
                const nextVal = parseInt(carrierData[i + 1]);
                if (nextVal > 1000) { // ARFCNé€šå¸¸æ˜¯å¤§æ•°å­—
                  bandPositions.push(i);
                }
              }
            }
            
            console.log('ğŸ” æ‰¾åˆ°é¢‘æ®µä½ç½®:', bandPositions);
            
            // è§£ææ¯ä¸ªè½½æ³¢
            for (const pos of bandPositions) {
              if (pos + 3 < carrierData.length) {
                const band = parseInt(carrierData[pos]);
                const arfcn = parseInt(carrierData[pos + 1]);
                const freq = parseInt(carrierData[pos + 2]);
                const bw = parseInt(carrierData[pos + 3]);
                
                console.log('ğŸ“¡ è½½æ³¢ä¿¡æ¯: band=' + band + ', arfcn=' + arfcn + ', freq=' + freq + ', bw=' + bw);
                
                if (band && arfcn) {
                  // æ ¹æ®é¢‘æ®µåˆ¤æ–­æ˜¯5G NRè¿˜æ˜¯LTE
                  if (band >= 77 && band <= 79) {
                    // n77, n78, n79 æ˜¯5Gé¢‘æ®µ
                    nrCount++;
                    const bandName = 'n' + band;
                    if (!bands.includes(bandName)) bands.push(bandName);
                    carrierInfo.push({
                      type: 'NR',
                      band: bandName,
                      arfcn: arfcn,
                      freq: freq,
                      bandwidth: bw
                    });
                  } else if (band >= 1 && band <= 50) {
                    // 1-50 é€šå¸¸æ˜¯LTEé¢‘æ®µ
                    lteCount++;
                    const bandName = 'b' + band;
                    if (!bands.includes(bandName)) bands.push(bandName);
                    carrierInfo.push({
                      type: 'LTE',
                      band: bandName,
                      arfcn: arfcn,
                      freq: freq,
                      bandwidth: bw
                    });
                  }
                }
              }
            }
            
            console.log('ğŸ“Š è½½æ³¢ç»Ÿè®¡: NR=' + nrCount + ', LTE=' + lteCount);
            console.log('ğŸ“‹ é¢‘æ®µåˆ—è¡¨:', bands);
          }
        }
      }
      
      // ğŸ”§ ä¿®å¤: æ”¹è¿›å¤‡ç”¨è§£ææ–¹æ³•
      if (nrCount === 0 && lteCount === 0) {
        console.log('âš ï¸ æ ‡å‡†è§£æå¤±è´¥ï¼Œå°è¯•å¤‡ç”¨è§£ææ–¹æ³•');
        
        // ğŸ”§ ç®€å•ä¿®å¤ï¼šç‰¹æ®Šå¤„ç†åŒ…å«78é¢‘æ®µçš„å“åº”
        if (response.includes('78,')) {
          // è®¡ç®—78é¢‘æ®µå‡ºç°çš„æ¬¡æ•°
          const band78Matches = (response.match(/,78,/g) || []).length;
          if (band78Matches > 0) {
            nrCount = band78Matches;
            bands.push('n78');
            console.log('ğŸ” æ£€æµ‹åˆ°', band78Matches, 'ä¸ªn78è½½æ³¢');
          }
        }
        
        // æ£€æŸ¥å“åº”ä¸­æ˜¯å¦åŒ…å«é¢‘æ®µä¿¡æ¯
        const responseStr = response.toString();
        
        // æŸ¥æ‰¾n78ç­‰5Gé¢‘æ®µ
        const nrBandMatches = responseStr.match(/\b(n?78|n?79|n?77)\b/gi);
        if (nrBandMatches) {
          nrCount = nrBandMatches.length;
          nrBandMatches.forEach(match => {
            const band = match.replace(/^n?/, 'n');
            if (!bands.includes(band)) bands.push(band);
          });
          console.log('ğŸ” å¤‡ç”¨è§£ææ‰¾åˆ°5Gé¢‘æ®µ:', nrBandMatches);
        }
        
        // æŸ¥æ‰¾LTEé¢‘æ®µ
        const lteBandMatches = responseStr.match(/\b([1-9]|[1-4][0-9]|50)\b/g);
        if (lteBandMatches && nrCount === 0) {
          // åªæœ‰åœ¨æ²¡æœ‰æ‰¾åˆ°5Gé¢‘æ®µæ—¶æ‰è®¤ä¸ºæ˜¯LTE
          lteCount = Math.min(lteBandMatches.length, 3); // é™åˆ¶LTEè½½æ³¢æ•°
          lteBandMatches.slice(0, 3).forEach(match => {
            const band = 'b' + match;
            if (!bands.includes(band)) bands.push(band);
          });
          console.log('ğŸ” å¤‡ç”¨è§£ææ‰¾åˆ°LTEé¢‘æ®µ:', lteBandMatches.slice(0, 3));
        }
        
        // å¦‚æœä»ç„¶æ²¡æœ‰æ‰¾åˆ°ï¼Œä½¿ç”¨é»˜è®¤å€¼
        if (nrCount === 0 && lteCount === 0) {
          // æ ¹æ®HFREQINFOå“åº”çš„å­˜åœ¨æ¨æ–­è‡³å°‘æœ‰ä¸€ä¸ªè½½æ³¢
          if (responseStr.includes('HFREQINFO:')) {
            nrCount = 1;
            bands.push('n78');
            console.log('ğŸ” å¤‡ç”¨è§£æä½¿ç”¨é»˜è®¤5Gé…ç½®');
          }
        }
      }
      
      const result = {
        nr_count: nrCount,
        lte_count: lteCount,
        bands: bands.length > 0 ? bands : ['n78'], // é»˜è®¤é¢‘æ®µ
        status: nrCount > 0 ? 'connected' : (lteCount > 0 ? 'lte_only' : 'disconnected'),
        raw_response: response,
        timestamp: new Date().toISOString()
      };
      
      console.log('âœ… 5GçŠ¶æ€è§£ææˆåŠŸ:', result);
      return result;
      
    } catch (error) {
      console.error('âŒ è§£æ5GçŠ¶æ€å¤±è´¥:', error);
      logger.error('è§£æ5GçŠ¶æ€å¤±è´¥:', error);
      return this.getMock5GStatus();
    }
  }

  // ğŸ”§ æ–°å¢: è·å–æ¨¡æ‹Ÿ5GçŠ¶æ€æ•°æ®
  private getMock5GStatus(): any {
    return {
      nr_count: 1,
      lte_count: 0,
      bands: ['n78'],
      status: 'connected',
      mock: true,
      message: 'ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ® - è®¾å¤‡å¯èƒ½æœªè¿æ¥æˆ–å‘½ä»¤ä¸æ”¯æŒ',
      timestamp: new Date().toISOString()
    };
  }

  // è§£æé”å®šçŠ¶æ€
  public parseLockStatus(response: string): LockStatus | null {
    try {
      console.log('ğŸ” æœåŠ¡ç«¯è§£æNRFREQLOCKå“åº”:', response);
      
      if (!response.includes('^NRFREQLOCK:')) {
        return {
          status: 'unlocked' as const,
          band: null,
          arfcn: null,
          pci: null,
          timestamp: new Date().toISOString()
        };
      }

      const lines = response.split('\n').map(line => line.trim()).filter(line => line);
      console.log('ğŸ“‹ æœåŠ¡ç«¯NRFREQLOCKå“åº”è¡Œ:', lines);
      
      // æŸ¥æ‰¾ ^NRFREQLOCK: è¡Œå’Œé…ç½®è¡Œ
      let mainStatus = 0;
      let configLine = '';
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line.startsWith('^NRFREQLOCK:')) {
          const statusMatch = line.match(/\^NRFREQLOCK:\s*(\d+)/);
          mainStatus = statusMatch ? parseInt(statusMatch[1]) : 0;
          
          // æŸ¥æ‰¾é…ç½®è¡Œ (é€šå¸¸åœ¨çŠ¶æ€è¡Œä¹‹å)
          for (let j = i + 1; j < lines.length && j < i + 3; j++) {
            if (lines[j] && !lines[j].startsWith('OK') && lines[j].includes(',')) {
              configLine = lines[j];
              break;
            }
          }
          break;
        }
      }
      
      console.log('ğŸ”¢ æœåŠ¡ç«¯ä¸»çŠ¶æ€:', mainStatus);
      console.log('âš™ï¸ æœåŠ¡ç«¯é…ç½®è¡Œ:', configLine);
      
      if (mainStatus === 0) {
        return {
          status: 'unlocked' as const,
          band: null,
          arfcn: null,
          pci: null,
          timestamp: new Date().toISOString()
        };
      }
      
      // è§£æé…ç½®è¡Œ
      if (configLine) {
        const params = configLine.split(',');
        if (params.length >= 4) {
          return {
            status: 'locked' as const,
            band: 'n' + params[0].trim(),
            arfcn: params[1].trim(),
            pci: params[3].trim(),
            timestamp: new Date().toISOString()
          };
        }
      }
      
      // é»˜è®¤é”å®šçŠ¶æ€
      return {
        status: 'locked' as const,
        band: 'n78',
        arfcn: '627264',
        pci: '579',
        timestamp: new Date().toISOString()
      };
      
    } catch (error) {
      console.error('æœåŠ¡ç«¯é”å®šçŠ¶æ€è§£æå¤±è´¥:', error);
      logger.error('è§£æé”å®šçŠ¶æ€å¤±è´¥:', error);
      return null;
    }
  }

  // è§£æå°åŒºæ‰«æç»“æœ
  public parseCellScanResults(response: string): ScanResult[] {
    try {
      const results: ScanResult[] = [];
      
      if (!response || !response.includes('^CELLSCAN:')) {
        logger.warn('æ‰«æå“åº”ä¸­æœªæ‰¾åˆ°CELLSCANæ•°æ®');
        return results;
      }

      // åˆ†å‰²å“åº”ä¸ºè¡Œ
      const lines = response.split('\n');
      
      for (const line of lines) {
        if (line.includes('^CELLSCAN:')) {
          try {
            // è§£æCELLSCANè¡Œæ ¼å¼: ^CELLSCAN: rat,plmn,freq,pci,band,lac,scs,rsrp,rsrq,sinr,lte_sinr
            const data = line.split('^CELLSCAN:')[1].trim();
            const parts = data.split(',');
            
            if (parts.length >= 11) {
              const scanResult: ScanResult = {
                rat: parts[0].replace(/"/g, '').trim(),
                plmn: parts[1].replace(/"/g, '').trim(),
                freq: parseInt(parts[2]) || 0,
                pci: parseInt(parts[3]) || 0,
                band: parseInt(parts[4]) || 0,
                lac: parseInt(parts[5]) || 0,
                scs: parts[6].replace(/"/g, '').trim(),
                rsrp: parseInt(parts[7]) || 0,
                rsrq: parseInt(parts[8]) || 0,
                sinr: parseInt(parts[9]) || 0,
                lte_sinr: parseInt(parts[10]) || 0,
                timestamp: new Date().toISOString()
              };
              
              results.push(scanResult);
            }
          } catch (parseError) {
            logger.warn('è§£æå•ä¸ªCELLSCANè¡Œå¤±è´¥:', parseError, 'è¡Œå†…å®¹:', line);
          }
        }
      }
      
      logger.info(`æˆåŠŸè§£æ ${results.length} ä¸ªå°åŒºæ‰«æç»“æœ`);
      return results;
      
    } catch (error) {
      logger.error('è§£æå°åŒºæ‰«æç»“æœå¤±è´¥:', error);
      return [];
    }
  }

  public get connected(): boolean {
    return this.isConnected;
  }
}
